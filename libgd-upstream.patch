From f7d12c91fa8bb0313dfc9d5ca827674c49a7bc9d Mon Sep 17 00:00:00 2001
From: Martin Reboredo <39890836+YakoYakoYokuYoku@users.noreply.github.com>
Date: Tue, 16 Mar 2021 12:53:16 -0300
Subject: [PATCH] Permit compilation with libheif version 1.7.0 (#686)

libheif versions that came before 1.9.0 don't support changing the output image chroma.
I did not notice that and it resulted with tests failures across other OSes that don't have
a much newer libheif.

See #678. Supersedes #685.
---
 src/gd_heif.c           | 14 ++++++++------
 tests/heif/heif_im2im.c |  3 +++
 2 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/src/gd_heif.c b/src/gd_heif.c
index 3b00a6c5..47ecd7ad 100644
--- a/src/gd_heif.c
+++ b/src/gd_heif.c
@@ -321,12 +321,14 @@ static int _gdImageHeifCtx(gdImagePtr im, gdIOCtx *outfile, int quality, gdHeifC
 		return GD_FALSE;
 	}
 
-	err = heif_encoder_set_parameter_string(heif_enc, "chroma", chroma);
-	if (err.code != heif_error_Ok) {
-		gd_error("gd-heif invalid chroma subsampling parameter\n");
-		heif_encoder_release(heif_enc);
-		heif_context_free(heif_ctx);
-		return GD_FALSE;
+	if (heif_get_version_number_major() >= 1 && heif_get_version_number_minor() >= 9) {
+		err = heif_encoder_set_parameter_string(heif_enc, "chroma", chroma);
+		if (err.code != heif_error_Ok) {
+			gd_error("gd-heif invalid chroma subsampling parameter\n");
+			heif_encoder_release(heif_enc);
+			heif_context_free(heif_ctx);
+			return GD_FALSE;
+		}
 	}
 
 	err = heif_image_create(gdImageSX(im), gdImageSY(im), heif_colorspace_RGB, heif_chroma_interleaved_RGBA, &heif_im);
diff --git a/tests/heif/heif_im2im.c b/tests/heif/heif_im2im.c
index 202d6b3e..01abf021 100644
--- a/tests/heif/heif_im2im.c
+++ b/tests/heif/heif_im2im.c
@@ -17,6 +17,9 @@ int main()
 	int size = 0;
 	CuTestImageResult result = {0, 0};
 
+	if (!gdTestAssertMsg(heif_get_version_number_major() == 1 && heif_get_version_number_minor() >= 9, "changing chroma subsampling is not supported in this libheif version\n"))
+		return 77;
+
 	if (!gdTestAssertMsg(heif_have_decoder_for_format(heif_compression_HEVC) && heif_have_encoder_for_format(heif_compression_HEVC), "HEVC codec support missing from libheif\n"))
 		return 77;
 
From f6a111c632fcf76dd3a42d750f18d2ed7bf8a5f1 Mon Sep 17 00:00:00 2001
From: Ben Morss <morss@google.com>
Date: Tue, 16 Mar 2021 12:26:17 -0400
Subject: [PATCH] Fix for libavif v0.8.2 (#680)

Don't return AVIF_RESULT_TRUNCATED_DATA, as this is normal for libavif <= 0.8.2. In our tests,
this makes tests pass with libavif 0.8.2.

Plus, we did a few things to stop compiler warnings - and added a newline to error output.

thanks @wantehchang for the collaboration here!

This fixes #677.
---
 src/gd_avif.c | 19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/src/gd_avif.c b/src/gd_avif.c
index cf94c70a..20906618 100644
--- a/src/gd_avif.c
+++ b/src/gd_avif.c
@@ -151,7 +151,7 @@ static avifBool isAvifSrgbImage(avifImage *avifIm) {
 */
 static avifBool isAvifError(avifResult result, const char *msg) {
 	if (result != AVIF_RESULT_OK) {
-		gd_error("avif error - %s: %s", msg, avifResultToString(result));
+		gd_error("avif error - %s: %s\n", msg, avifResultToString(result));
 		return AVIF_TRUE;
 	}
 
@@ -177,13 +177,18 @@ static avifResult readFromCtx(avifIO *io, uint32_t readFlags, uint64_t offset, s
 	void *dataBuf = NULL;
 	gdIOCtx *ctx = (gdIOCtx *) io->data;
 
+	// readFlags is unsupported
+	if (readFlags != 0) {
+		return AVIF_RESULT_IO_ERROR;
+	}
+
 	// TODO: if we set sizeHint, this will be more efficient.
 
-	if (offset > LONG_MAX || size < 0)
+	if (offset > INT_MAX || size > INT_MAX)
 		return AVIF_RESULT_IO_ERROR;
 
 	// Try to seek offset bytes forward. If we pass the end of the buffer, throw an error.
-	if (!ctx->seek(ctx, offset))
+	if (!ctx->seek(ctx, (int) offset))
 		return AVIF_RESULT_IO_ERROR;
 
 	dataBuf = gdMalloc(size);
@@ -194,7 +199,7 @@ static avifResult readFromCtx(avifIO *io, uint32_t readFlags, uint64_t offset, s
 
 	// Read the number of bytes requested.
 	// If getBuf() returns a negative value, that means there was an error.
-	int charsRead = ctx->getBuf(ctx, dataBuf, size);
+	int charsRead = ctx->getBuf(ctx, dataBuf, (int) size);
 	if (charsRead < 0) {
 		gdFree(dataBuf);
 		return AVIF_RESULT_IO_ERROR;
@@ -202,7 +207,7 @@ static avifResult readFromCtx(avifIO *io, uint32_t readFlags, uint64_t offset, s
 
 	out->data = dataBuf;
 	out->size = charsRead;
-	return charsRead == size ? AVIF_RESULT_OK : AVIF_RESULT_TRUNCATED_DATA;
+	return AVIF_RESULT_OK;
 }
 
 // avif.h says this is optional, but it seemed easy to implement.
@@ -339,7 +344,7 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromAvifPtr(int size, void *data)
 */
 BGD_DECLARE(gdImagePtr) gdImageCreateFromAvifCtx (gdIOCtx *ctx)
 {
-	int x, y;
+	uint32_t x, y;
 	gdImage *im = NULL;
 	avifResult result;
 	avifIO *io;
@@ -482,7 +487,7 @@ static avifBool _gdImageAvifCtx(gdImagePtr im, gdIOCtx *outfile, int quality, in
 
 	uint32_t val;
 	uint8_t *p;
-	int x, y;
+	uint32_t x, y;
 
 	if (im == NULL)
 		return 1;
